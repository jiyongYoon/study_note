# 배열

---

# 1. 이론 학습

- 데이터가 메모리 상에 연속적으로 저장되어 많은 수의 데이터를 저장하는 자료구조
- 인덱스와 데이터가 1:1 대응

|인덱스|1|2|3|4|5|
|---|---|---|---|---|---|
|데이터|'a'|'b'|'c'|'d'|'e'|

## 특징

- 미리 최대 길이를 정해서 생성해야 함

## 장점

- 인덱스로 빠르게 접근

## 단점

- 데이터 추가/삭제가 번거로움
  - 가변 길이 배열은 배열 크기 변경시마다 새로운 배열 생성
  - 데이터 삭제 시 인덱스를 유지하기 위해 빈 공간을 유지하여 공간 낭비

---

# 2. 구현 실습

## 구현된 MyArray

[MyArray.java](MyArray.java)

---

# 3. 구현하면서 느낀 점

처음에는 `.length()`와 같이 길이 변수를 메서드로 접근하도록 구현했었다.
그러나 최대한 기존 배열 메서드와 호환되도록 하려다보니 클래스 내에서 필드를 public 하게 오픈하여 `인스턴스변수명.length`와 같은 변수로 바로 접근이 가능하게 했다.

내가 아는 List와 같은 클래스는 `.size()`와 같은 메서드로 값을 가져오게 하는데 배열은 왜 필드값을 바로 접근하도록 했을까?

### 1. 고정된 크기와 단순성

생성 시 크기가 고정되며 이후에 변경되지 않기 때문에 메서드를 호출하여 동적으로 무언가를 할 필요가 없다. 따라서 단순하게 필드값에 접근하면 된다.
이 생각을 하고나니 필드값에 접근제어자를 붙이게 되었다.

- 기존

  ```java
  public class MyArray {
  
    public int[] arr;
    public int length;
    ...
  ```
  
- 수정

  ```java
  public class MyArray {
  
    public final int[] arr;
    public final int length;
    ...
  ```

### 2. 성능 최적화

메서드 호출 오버헤드 없이 CPU 사이클을 절약하여 접근하도록 해준다.

### 3. 메서드의 특징

불필요한 캡슐화를 피한다. 메서드는 결국 `특정 작업의 묶음`으로 이해할 수 있기 때문에, `length()`라고 하더라도 우리 생각과 다른 로직이 들어있을 수 있다.
그러나 필드값을 바로 접근한다면 그저 변수 혹은 값이라는 것을 더 직관적으로 알 수 있을 것이다.

---

# 4. 추가적인 도전과제

- 제네릭을 도입하여 여러가지 자료형이 가능하도록 구현
- (25-03-11 완료) 배열 복사
  - 현재 생성자에서는 외부에서 할당한 값을 바뀌면 내부에서 바로 바뀌는 문제점이 있을 수 있다.
    ```java
    public class MyArray {

    public final int[] arr;
    public final int length;

    public MyArray(int[] arrValues) {
      arr = arrValues; <- 이 부분
      ...
    ```
    파라미터 배열을 직접 사용하지 않고 값을 가지고 깊은 복사를 하여 할당하는 작업이 필요하겠다.

- (25-03-11 완료) 배열 내용을 문자열로 출력하는 기능 추가 `toString()`