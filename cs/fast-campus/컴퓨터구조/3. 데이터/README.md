# 3. 데이터

---

컴퓨터는 0, 1만 안다는데, 그럼 데이터들은 어떻게 0, 1 만으로 표현할 것인가?
- 모든 양수는 어떻게? `이진수`
- 모든 음수는 어떻게? `2의 보수`
- 모든 소수는 어떻게? `부동 소수점`
- 모든 문자는 어떻게? `문자 인코딩&디코딩`

## 1) 이진수

- 1이 넘어가면 자리올림을 하나 하는 수 체계
- 모든 양수를 표현할 수 있다.
- 그러나, 너무 길다..! -> 사람이 좀 편하게 읽기 위해 `16진법(16진수)`으로 표현하는 경우가 많음

> ### **왜 하필 16진수인가?**
> 
> 효율성과 가독성 때문!
> 
> **1. 효율성**
> 
> 16진수는 2의 4제곱이라 자연스럽게 매핑됨. 즉, 2진수 네자리를 16진수 한자리로 깔끔하게 표현할 수 있기 때문  
> - 이진수 `1111` = 16진수 `F` 
> 
> **2. 가독성**
> 
> 8비트(1바이트) 값을 이진수로 표현하면 8자리가 되는데, 16진수로표현하면 2자리로 끝남. 사람이 읽을 때 가독성을 좋게 하기 위해 사용하는 것임.

## 2) 2의 보수

- 어떤 수 n을 그보다 큰 2^n에서 뺀 값
- e.g.) 11(2) 의 2의 보수? --> 11(2) 보다 큰 2^n은 100(2)이므로, 100(2) - 11(2) = 1(2) 가 2의 보수가 된다.
  - 좀 쉽게,,, `모든 0과 1을 뒤집은 뒤 1을 더한 값`
  - 11(2) 의 2의 보수? --> 00(2) 뒤집고 1(2) 더하면 1(2)
- 2의 보수로 변환된 음수와 일반 이진수 양수를 구분하는 방법? -> CPU 내의 `플래그 레지스터` 사용 (CPU 학습때 재학습 예정)

## 3) 부동 소수점

```java
double a = 0.1;
double b = 0.2;
double c = 0.3;

if (a + b == c) {
  System.out.println("true");
} else {
  System.out.println("false")
}

==> false
```

- 1101.10101(2) 를 m X 2^n 꼴로 나타낸다면? (m = 가수, n = 지수)
  - 110.110101(2) X 2^1
  - 110110.101(2) X 2^-2
  - 수없이 많음
  - 때문에 컴퓨터는 가수 부분을 1.xxx 꼴로만 사용하고 있음.
- 그러면 왜 소수 덧셈이 정확하게 표현이 안되는 이런 현상이 나타나는가?
  1. 각 진법별로 소수가 모두 편하게 표현되는 것은 아니다.
     - 1/3 은 3진법(`1 X 3^-1`) 로 간단하게 표현이 가능해지지만 10진법(`1.xx X 10^n`) 꼴로 나타내려면 가수부분이 무한히 필요하다. (0.33333333333)
  2. 32bit, 64bit의 공간에 수를 표현하려다 보니, 어쩔 수 없이 짤리는 가수 부분이 존재한다.
  3. 이 부분에서 계산 시 오차가 발생하게 되는 것이다.

## 4) 문자 인코딩&디코딩

- 문자집합: 표현 가능한 문자 집합 (Character set)
- 문자 --(인코딩)--> 100101110100...
- 문자 <--(디코딩)-- 100101001010...

### 아스키 코드(ASCII)

- 알파벳, 아라비아 숫자, 일부 특수문자, 제어 문자 포함
- 기본적으로 8bit (오류검증 1bit 포함) -> 2^7 = 128가지 문자 표현 가능
- 아스키코드는 대응되는 표로 인코딩-디코딩이 진행됨
  ```java
  char a = 97;
  int b = 97;
  System.out.println(a); -> `a`
  System.out.println(b); -> `97`
  ```
- 길이가 짧기 때문에 다양한 문자 표현이 안됨

### 유니코드 (+ UTF-8, UTF-16)

- 같은 문자집합이라고 하더라도 인코딩 방식이 다양함
- 대부분의 언어, 특수문자, 이모티콘, 화살표 등이 포함됨
- 코드 포인트: 유니코드 문자에 부여된 고유한 수
  - 그러나 이 코드 포인트대로 대응되는 것은 아님
-> 코드 포인트를 `인코딩 하는 방식(UTF-8, UTF-16, UTF-32..)`에 따라서 대응되는 문자가 달라짐

```python
import unicodedata

input_value = input("인코딩할 값을 입력하세요: ")
print(input_value)

print("유니코드 코드 포인트:")
for char in input_value:
        code_point = ord(char)
        print(f"문자 '{char}': U+{code_point:04X}")

utf8_encoded = input_value.encode('utf-8')
print("UTF-8 인코딩 결과:", utf8_encoded)
print(input_value)

utf16_encoded = input_value.encode('utf-16')
print("UTF-16 인코딩 결과:", utf16_encoded)
print(input_value)
```

```shell
jyyoon@jyyoon:/mnt/c/Users/black/test$ python3 uni.py
인코딩할 값을 입력하세요: 윤지용
윤지용
유니코드 코드 포인트:
문자 '윤': U+C724
문자 '지': U+C9C0
문자 '용': U+C6A9
UTF-8 인코딩 결과: b'\xec\x9c\xa4\xec\xa7\x80\xec\x9a\xa9'
윤지용
UTF-16 인코딩 결과: b'\xff\xfe$\xc7\xc0\xc9\xa9\xc6'
윤지용
```
-> 같은 유니코드 코드 포인트를 가져도 인코딩 방법에 따라 결과물이 달라진다!

> ### 컴퓨터는 인코딩된 이진수를 어떻게 끊어 읽을까?
> 
> [임커밋 유튜브](https://youtu.be/XhcikMAnRd4?si=G0qsdqum9LiVuUDt)