# 메모리 관리 기법

---

## 1차, 2차 저장장치

- 저장장치는 1차 -> `RAM`, 2차 -> `HDD` 또는 `SSD`로 나눌 수 있다.
- 1자 처장장치는 2차에 비해 빠른만큼 비싸고, 휘발성이라는 특징이 있다.
- 2차 저장장치는 1차에 비해 느리지만 싸고, 비휘발성이라는 특징이 있다.
- 데이터의 특성에 맞게 저장창지가 활용되는 것이 효율적인 것이다.

## RAM 메모리 주소

- RAM 메모리는 각 `1 byte` 마다 일련번호, 즉 주소가 있다.
  - 이 주소가 32bit 숫자라면 32bit 시스템, 64bit 숫자라면 64bit 시스템이다.
    - 32bit 시스템 = 2^32byte = 약 42.9 byte의 메모리 단위를 관리할 수 있게 된다. -> 최대 `4GB`의 메모리 통제가 가능하다. 
    > **1 byte에 대해 복기해보자.**
    > 1. 영문자 한 글자를 저장할 수 있는 단위
    > 2. 컴퓨터 기억공간의 최소 단위 (관리 단위)
    > 3. 8bit 한 묶음 

## 메모리 관리자 (MMU)

- 데이터를 효율적으로 가져오기, 메모리에 배치, 재배치 등의 작업을 한다.
- 여러 프로세스가 `한정된 RAM` 공간을 나누어 써야한다.
  - 프로세스마다의 RAM 공간을 할당하여 점유하게 된다. 다 차면 프로세스를 더 실행할 수 없을까? 
  - 이 때, 활성화가 덜 되거나 등등의 메모리는 HDD 등으로 옮기는 등의 재배치가 진행된다.
  - 배치, 재배치를 할 때 `Page` 단위로 배치, 재배치를 하게 된다. (기본적으로 4kB) 
    - [관련내용 - 운영체제의 가상메모리](/cs/null-null-developer/1.%20넓고%20얕게%20외워서%20컴공%20전공자%20되기/3.%20운영체제/README.md)

## 절대주소와 상대주소

<img src="https://github.com/jiyongYoon/study_cs_note/assets/98104603/e790578c-1b79-44eb-a1f2-9e72c726a293" alt="adder" width="50%" />

- 0 ~ 360까지는 운영체제가 사용하는 메모리 영역이라 일반 프로세스들은 침범이 불가능하다.
  - 여기서 400 주소에 데이터가 들어간다면 `400`은 절대주소, 사용가능한 360부터 주소를 찾는다면 `40`이 상대주소가 된다.
  - 상대주소 = `Logical` = `Virtual`

<img src="https://github.com/jiyongYoon/study_cs_note/assets/98104603/edff50ba-162b-4b04-a6a6-b58f45a46a38" alt="adder" width="50%" />


## 가상 메모리 개요

<img src="https://github.com/jiyongYoon/study_cs_note/assets/98104603/82a78859-1bf1-429e-b5ab-f7a493a4039a" alt="adder" width="50%" />

- 각 프로세스마다 할당하는 메모리이다. (VMS, Virtual Memory Space)
- 실제 H/W에 물리적으로 할당되는 메모리(절대주소)와는 주소(상대주소)가 다르다.
  - 실제 H/W에는 실제 RAM과 HDD의 일부분을 함께 메모리 공간으로 사용하며, 
    HDD 부분은 RAM에 비해 많이 느리기 때문에 RAM 공간이 부족한 경우 OS가 자체적으로 판단하여 스왑하여 HDD로 빼기도 한다. 
    - ex, 최대 절전 모드의 경우, RAM에 있는 데이터들을 모두 HDD로 옮기고 전원을 종료하며, 전원을 다시 켜면 다시 RAM으로 올리는 등의 작업을 하여 유지한다.
- 실제 H/W의 **메모리 관리적인 측면**에서의 의미가 가장 크다.
  - Kernel에서 `MM(Memory Manager)`가 가상메모리 - 실제메모리 를 `Mapping Table(배열구조)`로 관리한다.
  - 만약 프로세스가 동작 중에 죽는 일이 발생하면, OS가 인지하여 실제 매핑 테이블에서 실제 H/W에 할당된 부분의 자원을 바로 회수할 수 있다!
  - 이를 통해 낭비 없이 컴퓨터 자원을 계속해서 최적화 하여 사용할 수 있다!

## 페이징 기법의 구현

<img src="https://github.com/jiyongYoon/study_cs_note/assets/98104603/28592b3a-858b-4f3f-8e93-5e32613b6a4d" alt="adder" width="50%" />

- (C언어) 만약 페이지 테이블에서 VA = <P, D> 의 P값(페이지)에 실제 할당된 물리 주소가 없는 경우, 해당 주소에 값을 할당하거나 접근하려고 할 때, `Page Fault!`와 같은 에러가 뜨는게, 이 이유(가상 주소와 물리 주소는 동일하지 않고, 중간에 커널의 매핑 테이블로 관리되기) 때문이다.

## 가상 메모리 접근 권한

<img src="https://github.com/jiyongYoon/study_cs_note/assets/98104603/a1bf5579-c138-4a84-8ef8-8e071884cb77" alt="adder" width="50%" />

- 페이지 테이블에서 메모리 주소 별로 권한을 체크한다. (수정 가능하다)