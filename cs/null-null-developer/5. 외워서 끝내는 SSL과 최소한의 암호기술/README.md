# 1. 기초 이론

## 1) Checksum(검사합)

- 원본과 복사본(다운로드 등)의 데이터 오류 여부 확인방법
- 자릿수를 유지하여 일정 계산을 통해 원본과 복사본이 값이 동일한지 확인하는 방법
- 단, 보안성이 없다. => `Hash`가 추가되어야 함
- 최종결과로 원본을 복원하는 것은 불가능하다.


## 2) Hash 함수

- 단방향성!
- 데이터 무결성 확보에 사용됨 (위변조 X)
- 사용처
  - 무결성 확보
    - 인증서 검증
    - 디지털 포렌식
    - 디지털 서명(Hash + PKI)
  - 패스워드 단방향 암호화
  - 블록체인
- 대표적인 알고리즘
  - `MD-5` 
    - 패스워드 암호화에는 사용금지
    - 길이가 너무 짧아서 Brute Force 공격에 뚫릴 가능성이 있음
  - `SHA-1`
  - `SHA-128, 256, 384, 512`
    - 숫자 길이가 클수록 경우의 수가 늘어나 보안성이 더 높아짐

> **해킹 가능성?**
> 
> MD-5로 해시했다는 정보를 알게 된다면, 해시값으로 원본값은 알 수 없지만, 많은 모수를 돌려서 동일한 해시값이 나오게 할 수 있음

> **SALT 값?**
> 
> 단방향 Hashing을 할 때, 데이터를 추가하여 Hashing을 하는 방법 => Hashing 할 때 변수가 2개이기 때문에 원본 추적이 훨씬 어려워짐

> **블록체인?**
> 
> 공개 데이터의 무결성을 확보하는 기술.
> 데이터를 체이닝하여 생성하는데, 위변조 보호를 위해 Hash가 사용된다.
> 체이닝 데이터 생성 시 바로 앞 데이터의 Hash값을 추가하여 Hashing을 진행하여 체이닝을 했을 때 데이터 위변조 난이도가 높아지며, 결국 불가능하게 되는 상황이 구현된다.
> 추가적인 핵심 개념으로 분산저장과 합의 매커니즘 등이 있다.

---

# 2. 암호기술에 대한 이해

## 1) 대칭키

- **키가 1개. 암호화 복호화에 모두 사용.**
- 비대칭키에 비해서 **효율적**
- DES, 3DES, SEED-128, ARIA, **AES-128**, **AES-256** 알고리즘 등이 있음
  - 논리연산 `XOR`을 사용하게 됨

## 2) 비대칭키

- 키가 2개, 1쌍. **하나는 암호화 / 하나는 복호화에 사용**
- 두 키 중에 공개하는 키를 공개키(Public key), 노출하지 않는 키를 개인키(Private key)라고 함
- 이러한 형태를 **PKI**(Public Key Infrastructure)라고 부름
- **RSA-2048**, ECC 알고리즘 등이 있음
  - `mod` 연산을 하게 되며, 이 중 `public key`와 `modulus`값이 공개키에 공개되어 있는 형태
    ```
    `평문` ^ {public key} mod {modulus} = `암호문`
    `암호문` ^ {private key} mod {modulus} = `평문`
    ```

## 3) 디지털 서명

<img src="https://github.com/user-attachments/assets/74503c59-ab27-4df4-81fd-29c64c9ad319" alt="adder" width="80%" />
- 정보의 무결성을 보장하는 과정
- 암호화 과정
  - `정보` -> `Hash` -> `내 Private key로 암호화`
- 복호화 과정
  - `암호화된 정보` -> `공개된 Public key로 복호화` -> `Hash`-> 나온 해시값 비교 